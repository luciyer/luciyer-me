{"componentChunkName":"component---src-templates-blog-post-js","path":"/queueable-apex-classes","result":{"data":{"site":{"siteMetadata":{"title":"luciyer.me"}},"ghostPost":{"title":"Queueable Apex Classes: Beyond @future Methods","html":"<figure class=\"kg-card kg-embed-card\"><iframe src=\"https://www.youtube.com/embed/dn9gWWyaCGg?feature=oembed\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen=\"\" name=\"fitvid0\" style=\"box-sizing: inherit; margin: 0px auto !important; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; line-height: inherit; font-family: inherit; font-size: 20px; vertical-align: middle; position: absolute; top: 0px; left: 0px; width: 700px; height: 393.75px;\"></iframe></figure><h3 id=\"introduction\">Introduction</h3><p>Queueable Apex classes aren’t the newest feature in Salesforce, but they are in my opinion one of the most useful. I hadn’t used them or even known of their existence until very recently when I ran into a roadblock on a project while trying to use @future methods (which are always asynchronous) in a synchronous manner!</p><h3 id=\"video-breakdown\">Video Breakdown</h3><p>In the video we will…</p><ul><li>Consider a few advantages of Queueable Apex</li><li>Talk about our use case and why chaining is necessary with Asynchronous methods</li><li>Build a class that performs a web service callout</li><li>Build two Queueable Apex classes, one of which implements the web service callout, the other which is called via a chain execution</li><li>See how to monitor the execution of those jobs</li></ul><h3 id=\"-future-methods-vs-queueable-apex-classes\">@future METHODs vs. Queueable APEX CLASSes</h3><p>Queueable Apex classes are a very clean way to schedule asynchronous jobs to run within Salesforce. It wouldn’t be wrong to consider them a superset of the functionality available in @future methods, as they can do essentially everything a future method can do, plus the following:</p><ul><li><strong><strong>Non-Primitive Types</strong></strong>: the methods within a queueable class have access to member variables which can be sObjects or custom Apex objects that you’ve created.</li><li><strong><strong>Chain Executions</strong></strong>. This was completely absent with future methods. One job can execute another job, allowing you to create a chain of actions — ie. dependent actions.</li><li><strong><strong>Job Tracking</strong></strong>: get an ID for each job and be able to monitor its execution rather than relying on debug logs or custom notifications generated from @future methods.</li></ul><h3 id=\"code-snippets-from-the-video\">Code Snippets From the Video</h3><h4 id=\"web-service-callout-class\">Web Service Callout Class</h4><p>This class hits a mockaroo API that returns a JSON object. This is meant to mimic a government or third-party database (in this case, Argentina’s government’s “AFIP” API) that provides data on companies: their addresses, industries, etc.</p><p>Just a reminder, if this type of code looks foreign to you, consider watching the video and reading the post about <a href=\"http://sfdc.guide/posts/defining-custom-rest-endpoints-with-apex/\">Apex REST Endpoints</a>.</p><pre><code class=\"language-java\">public class AFIP_Mock_Request {\n\n    private static String BASE_URL = 'https://api.mockaroo.com/api/generate.json';\n    private static final String API_KEY = 'c3b36a70';\n    \n    public ResponseWrapper Response;\n    \n    public AFIP_Mock_Request(String businessId) {\n                \n        this.Response = (ResponseWrapper)\n            JSON.deserialize(\n                getCalloutResponse(businessId), \n                AFIP_Mock_Request.ResponseWrapper.class\n            );\n        \n    }\n    \n    String getCalloutResponse (String businessId) {\n        \n\t    HttpRequest req = new HttpRequest();\n        \n        req.setEndpoint(BASE_URL + '?key=' + API_KEY + '&amp;schema=Afip_Mock&amp;count=1');\n        req.setMethod('POST');\n        \n        Http h = new Http();\n\t    HttpResponse res = h.send(req);\n    \treturn res.getBody();\n        \n    }\n    \n    public class ResponseWrapper {\n        public String Company_Name;\n        public String Tax_Condition;\n\t\tpublic String Street_Address;\n        public String City_Name;\n        public String State_Name;\n    }\n    \n}</code></pre><h4 id=\"our-first-queueable-class-enrichleaddata\">Our First Queueable Class – EnrichLeadData</h4><p>Which makes a callout using the class above and updates a Lead with the resulting information. Note: implements, along with <code>Queueable</code>, <code>Database.AllowsCallouts</code>.</p><pre><code class=\"language-java\">public class EnrichLeadData implements Queueable, Database.AllowsCallouts {\n\n    private String businessId;\n    private Lead leadToUpdate;\n    \n    public EnrichLeadData(Id leadId, String bId) {\n        this.businessId = bId;\n        this.leadToUpdate = [\n            SELECT Id, Company, Tax_Condition__c, Address \n            FROM Lead \n            WHERE Id =: leadId\n        ];\n    }\n\n    public void execute(QueueableContext context) {\n\n        AFIP_Mock_Request afipRequest = new AFIP_Mock_Request(this.businessId);\n\t\t        \n\t\tthis.leadToUpdate.Company = afipRequest.Response.Company_Name;\n        this.leadToUpdate.Tax_Condition__c = afipRequest.Response.Tax_Condition;\n        this.leadToUpdate.Street = afipRequest.Response.Street_Address;\n        this.leadToUpdate.City = afipRequest.Response.City_Name;\n        this.leadToUpdate.State = afipRequest.Response.State_Name;\n\n        try {\n\t        update this.leadToUpdate;            \n            Id callbackJobId = System.enqueueJob(new ConvertEnrichedLead(this.leadToUpdate.Id));\n        } catch (Exception e) {\n            System.debug(e.getMessage());\n        }\n\n    }\n    \n}</code></pre><h4 id=\"our-second-queueable-class-convertlead\">Our Second Queueable Class – ConvertLead</h4><p>Attempts to convert the now-enriched lead. This class’ constructor is called within the class directly above – creating a chain execution. This is necessary because we wouldn’t want to convert our lead automatically if it didn’t have the additional fields that are filled out by the web service callout.</p><pre><code class=\"language-java\">public class ConvertEnrichedLead implements Queueable {\n\n    private Lead leadToUpdate;\n    \n    public ConvertEnrichedLead(Id leadId) {\n\t\tthis.leadToUpdate = [SELECT Id FROM Lead WHERE Id =: leadId];\n    }\n    \n    public void execute(QueueableContext context) {\n    \n        LeadStatus convertStatus = [\n            SELECT Id, MasterLabel \n            FROM LeadStatus \n            WHERE IsConverted = TRUE LIMIT 1\n        ];\n        \n        Database.LeadConvert lc = new Database.LeadConvert();\n        lc.setLeadId(this.leadToUpdate.Id);\n        lc.setConvertedStatus(convertStatus.MasterLabel);\n        \n        Database.LeadConvertResult results = Database.convertLead(lc);\n        \n        if (!results.isSuccess())\n\t        System.debug(results.getErrors());\n        \n    }\n    \n}</code></pre><p>That’s all! Thanks for watching. You can find the official documentation <a href=\"https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_queueing_jobs.htm\">here</a>.</p>","published_at":"June 22, 2018","tags":[{"name":"salesforce","slug":"salesforce"}]}},"pageContext":{"slug":"queueable-apex-classes","previous":{"slug":"everything-you-need-to-know-about-custom-objects","title":"Everything You Need to Know about Custom Objects","primary_tag":{"name":"salesforce","slug":"salesforce"}},"next":{"slug":"invocable-apex-methods","title":"Invocable Apex Methods","primary_tag":{"name":"salesforce","slug":"salesforce"}}}}}